plugins {
    id 'net.minecraftforge.gradle'
    id 'org.parchmentmc.librarian.forgegradle'
    id 'org.spongepowered.mixin'
    
    id 'net.darkhax.curseforgegradle'
    id 'com.modrinth.minotaur'
}

apply plugin: 'org.parchmentmc.librarian.forgegradle'

base {
    archivesName = "${modid}-forge"
}

minecraft {
//    mappings channel: 'parchment', version: "1.19.3-${parchment_mappings_version}-${mc_version}"
    mappings channel: 'official', version: mc_version

    if (project.hasProperty('forge_ats_enabled') && project.findProperty('forge_ats_enabled').toBoolean()) {
        // This location is hardcoded in Forge and can not be changed.
        // https://github.com/MinecraftForge/MinecraftForge/blob/be1698bb1554f9c8fa2f58e32b9ab70bc4385e60/fmlloader/src/main/java/net/minecraftforge/fml/loading/moddiscovery/ModFile.java#L123
        accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')
        project.logger.debug('Forge Access Transformers are enabled for this project.')
    }

    runs {
        client {
            workingDirectory project.file('run')
            jvmArgs "-Xms${runtime_min_ram}", "-Xmx${runtime_max_ram}"
            property 'fml.earlyprogresswindow', 'false'
            if (project(":common").file("src/main/resources/${modid}.common.mixins.json").exists()) {
                arg "-mixin.config=${modid}.common.mixins.json"
            }
            if (project.file("src/main/resources/${modid}.forge.mixins.json").exists()) {
                arg "-mixin.config=${modid}.forge.mixins.json"
            }
            ideaModule "${rootProject.name}.${project.name}.main"
            taskName 'Client'
            property 'terminal.ansi', 'true'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
            property 'mixin.debug.export', mixin_debug
            mods {
                modClientRun {
                    source sourceSets.main
                    source project(":common").sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')
            jvmArgs "-Xms${runtime_min_ram}", "-Xmx${runtime_max_ram}"
            arg 'nogui'
            property 'fml.earlyprogresswindow', 'false'
            if (project(":common").file("src/main/resources/${modid}.common.mixins.json").exists()) {
                arg "-mixin.config=${modid}.common.mixins.json"
            }
            if (project.file("src/main/resources/${modid}.forge.mixins.json").exists()) {
                arg "-mixin.config=${modid}.forge.mixins.json"
            }
            ideaModule "${rootProject.name}.${project.name}.main"
            taskName 'Server'
            property 'terminal.ansi', 'true'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
            property 'mixin.debug.export', mixin_debug
            mods {
                modServerRun {
                    source sourceSets.main
                    source project(":common").sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')
            jvmArgs "-Xms${runtime_min_ram}", "-Xmx${runtime_max_ram}"
            if (project(":common").file("src/main/resources/${modid}.common.mixins.json").exists()) {
                arg "-mixin.config=${modid}.common.mixins.json"
            }
            if (project.file("src/main/resources/${modid}.forge.mixins.json").exists()) {
                arg "-mixin.config=${modid}.forge.mixins.json"
            }
            args '--mod', modid, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')
            ideaModule "${rootProject.name}.${project.name}.main"
            taskName 'Data'
            property 'terminal.ansi', 'true'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
            property 'mixin.debug.export', mixin_debug
            mods {
                modDataRun {
                    source sourceSets.main
                    source project(":common").sourceSets.main
                }
            }
        }
    }
}

sourceSets.main.resources.srcDir 'src/generated/resources'

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"
    annotationProcessor("org.spongepowered:mixin:0.8.5-SNAPSHOT:processor")
    
    compileOnly project(":common")

    // Mods
    implementation fg.deobf("curse.maven:konkrete-410295:4583493")
    implementation fg.deobf("curse.maven:fancymenu-forge-367706:4584006")
    runtimeOnly fg.deobf("curse.maven:catalogue-459701:4590890")
}

mixin {
    if (project.file("src/main/resources/${modid}.forge.mixins.json").exists() || project(":common").file("src/main/resources/${modid}.common.mixins.json").exists()) {
        add project(":common").sourceSets.main, "${modid}.refmap.json"
    }
    if (project(":common").file("src/main/resources/${modid}.common.mixins.json").exists()) {
        config "${modid}.common.mixins.json"
    }
    if (project.file("src/main/resources/${modid}.forge.mixins.json").exists()) {
        config "${modid}.forge.mixins.json"
    }
}

processResources {
    from project(":common").sourceSets.main.resources
    exclude("**/quilt.mod.json")
}

tasks.withType(JavaCompile).configureEach {
    source(project(":common").sourceSets.main.allSource)
}
tasks.withType(Javadoc).configureEach {
    source(project(":common").sourceSets.main.allJava)
}
tasks.named("sourcesJar", Jar) {
    from(project(":common").sourceSets.main.allSource)
}

jar.finalizedBy('reobfJar')

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId project.group
            artifactId project.archivesBaseName
            version project.version
            from components.java
        }
    }

    repositories {
        maven {
            url "file://" + System.getenv("local_maven")
        }
    }
}

import net.darkhax.curseforgegradle.TaskPublishCurseForge

task curseforge(type: TaskPublishCurseForge) {
    if (!file('../CHANGELOG.md').canRead()) { throw new FileNotFoundException("Could not read changelog file") }

    disableVersionDetection()
    apiToken = curseforge_api_token

    def mainFile = upload(project_curse_id, jar)
    mainFile.changelog = file('../CHANGELOG.md')
    mainFile.changelogType = 'markdown'
    mainFile.displayName = "[Forge] ${mc_version} | v${mod_version} " + rootProject.UppercaseString("${project_release_type}")
    mainFile.releaseType = project_release_type
    mainFile.addOptional('fancymenu-forge')
    mainFile.addGameVersion("Forge")
    project_game_versions.split(",").each {
        mainFile.addGameVersion(it.trim())
    }
}

modrinth {
    if (!file('../CHANGELOG.md').canRead()) { throw new FileNotFoundException("Could not read changelog file") }

    token = modrinth_api_token

    projectId = project_modrinth_id
    versionNumber = project.version
    versionName = "[Forge] ${mc_version} | v${mod_version} " + rootProject.UppercaseString("${project_release_type}")
    changelog = file('../CHANGELOG.md').text
    versionType = project_release_type
    uploadFile = jar
    loaders.add 'forge'
    dependencies {
        optional.project "fancymenu"
    }
    project_game_versions.split(",").each {
        gameVersions.add(it.trim())
    }
}

import groovy.json.*

task copyJarToDir(type: Copy) {
    onlyIf { project.hasProperty('build_jar_output_dir') && project.hasProperty('unique_build_number') }
    if (project.findProperty('copy_build_jar').toBoolean()) {
        // shortcut for jar.outputs.files
        from jar
        into project.findProperty('build_jar_output_dir')
        // add build number to be able to distinguish jars when testing thorough official launcher
        // build number is stored in global gradle.properties
        rename { fileName -> fileName.replace("v${mod_version}", "v${mod_version}-build.${unique_build_number}") }
    }
}

task refreshUpdateJson {
    onlyIf { project.hasProperty('mod_resources') }
    doLast {
        def updateFile = file(project.findProperty('mod_resources').concat(File.separator).concat('updates').concat(File.separator).concat("${modid}").concat('.json'))
        def updateJson
        if (updateFile.exists() && updateFile.canRead() && updateFile.length() != 0) {
            updateJson = new JsonSlurper().parseText(updateFile.text)
            "${project_game_versions}".replaceAll(" ", "").split(",").each { version ->
                updateJson['promos']["${version}-latest"] = "${mod_version}"
                // alpha and beta releases will contain 'a' or 'b' char respectively, don't update recommended for those
                if ("${mod_version}".matches("[^a-zA-Z]+")) {
                    updateJson['promos']["${version}-recommended"] = "${mod_version}"
                }
            }
        } else {
            def builder = new JsonBuilder()
            updateJson = builder {
                homepage "${mod_page_url}"
                promos { "${project_game_versions}".replaceAll(" ", "").split(",").each { version ->
                    "${version}-latest" "${mod_version}"
                    // alpha and beta releases will contain 'a' or 'b' char respectively, don't update recommended for those
                    if ("${mod_version}".matches("[^a-zA-Z]+")) {
                        "${version}-recommended" "${mod_version}"
                    }
                } }
            }
        }
        def output = new JsonOutput()
        updateFile.write(output.prettyPrint(output.toJson(updateJson)))
    }
}

build.finalizedBy project.tasks.copyJarToDir, rootProject.tasks.incrementBuildNumber
[tasks.modrinth, tasks.curseforge].each {it.finalizedBy project.tasks.refreshUpdateJson}
